import math
import numpy as np
from control import PID


class Motor:
    """
    Simple motor model with an internal PID controller.

    The motor is modeled as a discrete-time first-order system:
        x[k+1] = A * x[k] + B * u[k]
        y[k]   = C * x[k]

    where:
        - x represents the internal motor state (velocity),
        - u is the control input generated by the PID,
        - y is the measured motor velocity.

    This model abstracts actuator dynamics while keeping
    the control loop realistic.
    """

    def __init__(self, kp=1.0, ki=0.5, kd=0.0):
        # Discrete-time state-space coefficients
        self.A = 1.0
        self.B = 1.0
        self.C = 1.0

        # Internal motor state (velocity)
        self.x = 0.0

        # Dedicated PID controller acting on velocity error
        self.pid = PID(kp, ki, kd)

    def step(self, ref, dt):
        """
        Advance motor dynamics by one time step.

        Args:
            ref (float): desired motor velocity reference
            dt  (float): simulation time step

        Returns:
            float: measured motor velocity
        """
        # Velocity tracking error
        error = ref - self.x

        # PID computes the control input u
        u = self.pid.compute(error, dt)

        # Motor state update (first-order dynamics)
        self.x = self.A * self.x + self.B * u

        # Output equation (measurement model)
        return self.C * self.x

class Robot:
    """
    Differential-drive robot model in 2D.

    The robot is composed of two independent motors (left and right),
    each controlled by its own PID. The kinematics follow the standard
    differential-drive (unicycle-equivalent) model.

    Positions are expressed in grid cells for simplicity.
    """

    def __init__(self, x, y, theta=0.0, radius=12.0, wheel_base=24.0,
                 kp=1.0, ki=0.2, kd=0.0):

        # True robot pose (ground truth)
        self.x = float(x)
        self.y = float(y)
        self.theta = float(theta)

        # GPS-like pose (optional noisy measurements)
        self.x_gps = float(x)
        self.y_gps = float(y)

        # Constant bias affecting angular velocity (IMU drift model)
        self.bias = 0.0017

        # Robot geometry
        self.radius = float(radius)          # collision radius [cells]
        self.wheel_base = float(wheel_base)  # distance between wheels [cells]

        # Commanded body velocities
        self.v_cmd = 0.0  # linear velocity
        self.w_cmd = 0.0  # angular velocity

        # Left and right motors (independent actuators)
        self.mL = Motor(kp, ki, kd)
        self.mR = Motor(kp, ki, kd)

        # Encoder accumulators (integrated wheel velocities)
        self.vL_enc_ = 0.0
        self.vR_enc_ = 0.0

        # IMU-related internal variables
        self.bias_ = 0.0017        # gyro bias
        self.a_ = 0.0001           # bias drift rate
        self.yaw_rate_ = 0.0       # measured yaw rate
        self.w_true_ = 0.0         # true angular velocity

    def step(self, dt, vdes, wdes):
        """
        Advance robot dynamics by one simulation step.

        Args:
            dt   (float): time step
            vdes (float): desired linear velocity
            wdes (float): desired angular velocity
        """

        # Differential-drive inverse kinematics:
        # map (v, w) into left/right wheel velocities
        Vldes = vdes - wdes * (self.wheel_base / 2.0)
        VRdes = vdes + wdes * (self.wheel_base / 2.0)

        # Motor dynamics with internal PID control
        vL = self.mL.step(Vldes, dt)
        vR = self.mR.step(VRdes, dt)

        # True angular velocity (noise-free, before sensors)
        self.w_true_ = (vR - vL) / self.wheel_base

        # Add measurement noise to wheel velocities (encoder noise)
        vL = vL + np.random.normal(0, 0.05)
        vR = vR + np.random.normal(0, 0.05)

        # Reconstruct body velocities from wheel velocities
        self.v_cmd = (vL + vR) / 2.0
        self.w_cmd = (vR - vL) / self.wheel_base

        # Forward kinematics (pose integration)
        self.x += self.v_cmd * math.cos(self.theta) * dt
        self.y += self.v_cmd * math.sin(self.theta) * dt
        self.theta += self.w_cmd * dt

        # Update encoder accumulators
        self.upload_enc_(vL, vR)

        # Update IMU measurement (gyro with bias + noise)
        self.upload_imu_(self.w_true_, dt)

        # Normalize orientation to [-pi, pi]
        if self.theta > math.pi:
            self.theta -= 2.0 * math.pi
        elif self.theta < -math.pi:
            self.theta += 2.0 * math.pi
    def upload_enc_(self, vel_left, vel_right):
        """
        Accumulate wheel velocities to emulate encoder integration.
        """
        self.vL_enc_ += vel_left
        self.vR_enc_ += vel_right

    def get_enc(self, N):
        """
        Return average wheel velocities over N samples
        and reset accumulators.
        """
        res_L = self.vL_enc_ / N
        res_R = self.vR_enc_ / N

        self.vL_enc_ = 0.0
        self.vR_enc_ = 0.0

        return res_L, res_R

    def upload_bias_(self, dt):
        """
        Bias random-walk model (integrated drift).
        """
        self.bias_ = self.bias_ + self.a_ * dt

    def upload_imu_(self, w, dt):
        """
        Simulate gyroscope measurement:
        true angular velocity + bias + white noise.
        """
        self.yaw_rate_ = w + self.bias_ + np.random.normal(0, 0.025)
        self.upload_bias_(dt)


    def collides_with_env(self, env):
        """
        Check collision between the robot (circle)
        and the grid-based environment.
        """
        r = self.radius
        x_min = int(math.floor(self.x - r))
        x_max = int(math.floor(self.x + r))
        y_min = int(math.floor(self.y - r))
        y_max = int(math.floor(self.y + r))

        W = env.width_cells
        H = env.height_cells

        for cy in range(max(0, y_min), min(H - 1, y_max) + 1):
            for cx in range(max(0, x_min), min(W - 1, x_max) + 1):
                if env.grid[cy][cx] == 1:
                    if _circle_rect_intersect(
                        self.x, self.y, r,
                        cx, cy, cx + 1.0, cy + 1.0
                    ):
                        return True
        return False


    def draw(self, canvas, env, tag="robot"):
        """
        Draw the robot (circle + heading + wheels) on a Tkinter canvas.
        """
        S = env.cell_px  # scale [cells â†’ pixels]
        cx = self.x * S
        cy = self.y * S
        rpx = self.radius * S

        # Body (circle)
        canvas.create_oval(
            cx-rpx, cy-rpx, cx+rpx, cy+rpx,
            outline="#212121", width=2, tags=tag
        )

        # Heading line
        hx = cx + rpx * math.cos(self.theta)
        hy = cy + rpx * math.sin(self.theta)
        canvas.create_line(cx, cy, hx, hy, width=3, tags=tag)


def _circle_rect_intersect(cx, cy, r, rx0, ry0, rx1, ry1):
    """Check if circle (cx,cy,r) intersects rectangle [rx0,rx1]x[ry0,ry1]."""
    closest_x = min(max(cx, rx0), rx1)
    closest_y = min(max(cy, ry0), ry1)
    dx = cx - closest_x
    dy = cy - closest_y
    return (dx*dx + dy*dy) <= (r*r)
